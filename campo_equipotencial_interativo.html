<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulação Interativa: Campo Equipotencial</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* ------------------------------------- */
        /* Estilos Gerais e Layout de 3 Colunas (Adaptado) */
        /* ------------------------------------- */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #f4f4f9;
        }

        .menu-link {
            display: block;
            padding: 15px;
            background-color: #343a40;
            color: white;
            text-align: center;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .menu-link:hover {
            background-color: #1d2124;
        }

        .main-content {
            display: flex;
            flex-grow: 1;
        }
        
        /* Estilo para as três colunas */
        .coluna {
            flex: 1; 
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            border-right: 1px solid #ccc;
        }
        /* Remove a borda da última coluna */
        .coluna:last-child {
            border-right: none;
        }

        /* Cores de fundo para as colunas */
        .coluna-midia {
            background-color: #f8f9fa; /* Cinza claro */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .coluna-simulacao {
            background-color: #e9ecef; /* Cor original de equipotencial */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .coluna-explicacao {
            background-color: #ffffff; /* Branco */
        }
        
        /* ------------------------------------- */
        /* Responsividade: 3 colunas em desktop, empilhadas em mobile */
        /* ------------------------------------- */
        @media (max-width: 992px) { 
            .main-content {
                flex-direction: column;
            }
            .coluna {
                 border-right: none;
                 border-bottom: 2px solid #ccc; 
            }
            .coluna:last-child {
                border-bottom: none;
            }
        }


        /* ------------------------------------- */
        /* Estilos de Componentes */
        /* ------------------------------------- */

        h2 {
            text-align: center;
            /* Cor verde para Equipotencial */
            color: #28a745; 
            border-bottom: 2px solid #28a745; 
            padding-bottom: 10px;
            margin-top: 0;
            width: 100%;
            margin-bottom: 20px;
        }
        
        /* Estilos para o Canvas da Simulação */
        canvas {
            border: 1px solid #ddd;
            background-color: #ffffff; 
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            cursor: grab; 
            max-width: 100%;
        }
        canvas:active {
             cursor: grabbing;
        }

        .legenda {
            margin-top: 15px;
            font-size: 0.9em;
            color: #555;
            text-align: center;
        }
        
        /* Descrição */
        .simulacao-descricao, .descricao-texto {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            width: 100%;
            text-align: left;
        }

        /* ---------------------------------------------------- */
        /* Estilos do Vídeo Miniatura e Botão de Controle */
        /* ---------------------------------------------------- */

        #videoNarradorMini {
            width: 150px; /* Tamanho da bolinha do vídeo */
            height: 150px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid #28a745; /* Borda de destaque verde */
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.6);
            transition: transform 0.3s ease;
            z-index: 10;
            margin-bottom: 20px;
        }

        #videoNarradorMini video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Garante que o vídeo preencha o círculo */
        }
        
        /* Estilo do Botão de Play/Pause */
        #btnControleNaracao {
            display: block;
            width: 100%;
            max-width: 250px;
            padding: 10px;
            margin-top: 10px;
            background-color: #28a745; /* Verde para Play */
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #btnControleNaracao.paused {
            background-color: #ffc107; 
            color: #333;
        }
        #btnControleNaracao.playing {
            background-color: #dc3545; 
        }
        #btnControleNaracao:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        /* Controles específicos da simulação */
        .config-select-group {
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            margin-top: 15px;
            text-align: center;
            width: 100%;
            max-width: 300px;
        }
        .config-select-group label {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: block;
        }
        .config-select-group select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            width: 90%;
            cursor: pointer;
        }
        
        /* ---------------------------------------------------- */
        /* ESTILOS DO FLUXOGRAMA (NOVO) */
        /* ---------------------------------------------------- */
        .flowchart-panel { 
            min-width: 400px; 
            background: #ffffff; 
            padding: 0; 
            border-radius: 8px; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); 
        } 
        .flowchart-panel h3 { 
            color: #00416A; 
            margin-bottom: 20px; 
            font-size: 24px; 
            text-align: center; 
        } 
        .flow-step {
            background: #f8f9fa;
            border-left: 4px solid #28a745; /* Cor da linha vertical (Verde para Equipotencial) */
            padding: 15px 20px;
            margin: 25px auto;
            border-radius: 0 8px 8px 0;
            position: relative;
            max-width: 90%;
            text-align: center;
        }
        .flow-step::after {
            content: '↓';
            position: absolute;
            bottom: -28px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #ccc;
            font-weight: bold;
        }
        .flow-step:last-child::after { content: ''; }
        .flow-step strong { color: #28a745; display: block; margin-bottom: 8px; font-size: 1.1em; }
        .flow-step p { font-size: 0.95em; line-height: 1.6; color: #555; }

        /* Ajuste do padding na coluna para comportar o novo painel */
        .coluna-explicacao {
            padding: 20px 0; 
        }

    </style>
</head>
<body>

    <a href="index.html" class="menu-link">← Voltar para o Menu Principal</a>

    <div class="main-content">
        
        <div class="coluna coluna-midia">
            <h2>Personagem e Narração TTS</h2>
            
            <div id="videoNarradorMini">
                <video id="videoProfessor" loop muted autoplay width="100%" height="100%">
                    <source src="video_professor.mp4" type="video/mp4">
                    Seu navegador não suporta a tag de vídeo.
                </video>
            </div>
            
            <button id="btnControleNaracao" class="paused" disabled>
                <span class="play-icon">▶</span> Carregando Narração...
            </button>
            
            <p style="text-align: center; margin-top: 15px; font-size: 0.9em; color: #555;">
                O vídeo acima é um elemento visual em loop. Use o botão para iniciar a narração por voz (TTS).
            </p>

        </div>

        <div class="coluna coluna-simulacao">
            <h2>Simulação Interativa: Campo Equipotencial</h2>
            
            <canvas id="eFieldCanvas" width="500" height="500"></canvas>
            
            <div class="config-select-group">
                <label for="configuracaoCargas">Escolha a Configuração de Carga:</label>
                <select id="configuracaoCargas" onchange="mudarConfiguracao()">
                    <option value="dipolo">Dipolo Clássico (+ e -)</option>
                    <option value="iguais_pos">Cargas Iguais (+ e +)</option>
                    <option value="iguais_neg">Cargas Iguais (- e -)</option>
                </select>
            </div>

            <p class="legenda">Linhas vermelhas sólidas com setas são as Linhas de Campo Elétrico E. Linhas azuis sólidas são as Linhas Equipotenciais (Potencial V).</p>
            
            <div class="simulacao-descricao">
                <h3>Instruções e Observações:</h3>
                <p><strong>Arraste:</strong> Clique e arraste as cargas no Canvas para alterar suas posições e ver o campo se reconfigurar.</p>
                <p><strong>Cores/Sinal:</strong> Cargas Vermelhas são positivas (+). Cargas Azuis são negativas (-).</p>
                <p><strong>Perpendicularidade:</strong> Note que as linhas de campo E e as linhas equipotenciais V são sempre perpendiculares entre si.</p>
            </div>
        </div>

        <div class="coluna coluna-explicacao">
            
            <h2>Fluxograma Explicativo: Potencial e Equipotenciais</h2>
            
            <div class="flowchart-panel">
                <div class="flow-step">
                    <strong>1. Potencial Elétrico (V)</strong>
                    <p>É a energia potencial elétrica por unidade de carga. É uma grandeza escalar, medida em Volts (J/C).</p>
                </div>
                <div class="flow-step">
                    <strong>2. Linhas Equipotenciais</strong>
                    <p>Curvas que ligam todos os pontos do espaço com o mesmo valor de potencial (V).</p>
                </div>
                <div class="flow-step">
                    <strong>3. Perpendicularidade</strong>
                    <p>O Campo Elétrico (E vetor) é sempre perpendicular às Linhas Equipotenciais (Potencial V é constante).</p>
                </div>
                <div class="flow-step">
                    <strong>4. Trabalho (W)</strong>
                    <p>Mover uma carga sobre uma linha equipotencial não requer trabalho: W = 0, pois a variação de potencial (Delta V) é zero.</p>
                </div>
                <div class="flow-step">
                    <strong>5. Gradiente de Potencial</strong>
                    <p>O campo (E vetor) aponta na direção em que o potencial (V) **diminui** mais rapidamente (E é o negativo do gradiente de V).</p>
                </div>
                <div class="flow-step">
                    <strong>6. Intensidade do Campo</strong>
                    <p>Linhas equipotenciais **mais próximas** indicam que a variação de V é rápida, ou seja, o campo (E vetor) é **mais intenso**.</p>
                </div>
            </div>
        </div>
        
    </div>

<script>
    // --- Constantes e Configurações (Simulação) ---
    const LARGURA_JANELA = 500;
    const ALTURA_JANELA = 500;
    const RAIO_CARGA = 12; 
    const K_ELETROSTATICA = 1000; // Constante de escala para cálculo
    const MAGNITUDE_FIXA = 1.0; 
    
    // Mapeamento de Coordenadas (Mundo)
    const xLim = [-4, 4]; // -4 a 4 no mundo mapeia para 0 a 500px
    const yLim = [-4, 4];

    // Configuração de Desenho
    const RESOLUTION_DRAW = 20; // Resolução do Marching Squares (tamanho do pixel da grade)
    const NUM_EQUIPOTENTIALS = 5; // Níveis de contorno (Mais limpo)
    const NUM_STREAMS = 20;       // Número de linhas de campo
    const STREAM_STEP_SIZE = 0.2; // Passo da linha de campo no mundo (unidade)
    const SETA_INTERVALO = 1.5;   // Distância entre as setas na unidade do mundo
    
    // Variáveis Globais
    let canvas, ctx;
    let cargaArrastada = null; 
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 }; 

    // Classe de Carga
    class Charge {
        constructor(q, x, y) {
            this.q = q; 
            this.x = x; 
            this.y = y;
            this.radius = 12; // Raio de desenho no Canvas
        }
    }
    
    let CARGAS = [];

    // --- Mapeamento de Coordenadas ---

    function worldToCanvas(worldX, worldY) {
        const scaleX = LARGURA_JANELA / (xLim[1] - xLim[0]);
        const scaleY = ALTURA_JANELA / (yLim[1] - yLim[0]);
        const originX = LARGURA_JANELA / 2;
        const originY = ALTURA_JANELA / 2;
        
        return {
            x: originX + worldX * scaleX,
            y: originY - worldY * scaleY 
        };
    }

    function canvasToWorld(canvasX, canvasY) {
        const scaleX = LARGURA_JANELA / (xLim[1] - xLim[0]);
        const scaleY = ALTURA_JANELA / (yLim[1] - yLim[0]);
        const originX = LARGURA_JANELA / 2;
        const originY = ALTURA_JANELA / 2;
        
        return {
            x: (canvasX - originX) / scaleX,
            y: (originY - canvasY) / scaleY 
        };
    }

    // --- Funções de Controle de Carga ---
    
    function inicializarCargas() {
        const CHARGE_START_DISTANCE = 2.0; 
        
        CARGAS = [ 
            new Charge(MAGNITUDE_FIXA, -CHARGE_START_DISTANCE, 0), 
            new Charge(-MAGNITUDE_FIXA, CHARGE_START_DISTANCE, 0)  
        ];
        mudarConfiguracao(); 
    }

    function mudarConfiguracao() {
        // Para parar qualquer narração em curso durante a mudança de configuração
        window.speechSynthesis.cancel();
        isSpeaking = false;
        
        btnControle.textContent = "▶ PLAY Narração";
        btnControle.classList.remove('playing');
        btnControle.classList.add('paused');
        currentUtteranceIndex = 0; // Reinicia o índice
        
        const config = document.getElementById('configuracaoCargas').value;
        const magnitude = MAGNITUDE_FIXA; 

        let q1_sinal, q2_sinal;

        if (config === 'dipolo') {
            q1_sinal = 1;
            q2_sinal = -1;
        } else if (config === 'iguais_pos') {
            q1_sinal = 1;
            q2_sinal = 1;
        } else if (config === 'iguais_neg') {
            q1_sinal = -1;
            q2_sinal = -1;
        }

        CARGAS[0].q = q1_sinal * magnitude;
        CARGAS[0].cor = q1_sinal > 0 ? "#FF3333" : "#3366FF";
        CARGAS[0].label = q1_sinal > 0 ? "+" : "−";

        CARGAS[1].q = q2_sinal * magnitude;
        CARGAS[1].cor = q2_sinal > 0 ? "#FF3333" : "#3366FF";
        CARGAS[1].label = q2_sinal > 0 ? "+" : "−";
        
        animar(); 
    }
    
    // --- Funções de Cálculo ---

    function getPotentialAt(x, y) {
        let potential = 0;
        for (const c of CARGAS) {
            const dx = x - c.x;
            const dy = y - c.y;
            const r = Math.sqrt(dx * dx + dy * dy);
            if (r > 0.01) { 
                potential += K_ELETROSTATICA * c.q / r;
            }
        }
        return potential;
    }
    
    function getFieldAt(x, y) {
        let Ex = 0, Ey = 0;
        for (const c of CARGAS) {
            const dx = x - c.x;
            const dy = y - c.y;
            const r2 = dx * dx + dy * dy;
            const r = Math.sqrt(r2);
            
            if (r < 0.1) continue; 
            
            const E_magnitude = K_ELETROSTATICA * c.q / r2;
            Ex += E_magnitude * dx / r;
            Ey += E_magnitude * dy / r;
        }
        const mag = Math.sqrt(Ex * Ex + Ey * Ey);
        return { Ex, Ey, mag };
    }
    
    // --- Desenho Avançado (Marching Squares para Equipotenciais) ---

    function drawEquipotentials() {
        const resolution = RESOLUTION_DRAW; 
        const gridWidth = LARGURA_JANELA / resolution;
        const gridHeight = ALTURA_JANELA / resolution;
        const potentialGrid = [];
        
        // 1. Calcular o potencial em cada ponto da grade (Canvas)
        for (let i = 0; i <= gridWidth; i++) {
            potentialGrid[i] = [];
            for (let j = 0; j <= gridHeight; j++) {
                const canvasX = i * resolution;
                const canvasY = j * resolution;
                const worldCoord = canvasToWorld(canvasX, canvasY);
                potentialGrid[i][j] = getPotentialAt(worldCoord.x, worldCoord.y);
            }
        }
        
        // 2. Definir Níveis (Adaptativo e Reduzido)
        let levels = [];
        // Gera 5 níveis positivos e 5 negativos (total de 10 linhas)
        for(let i = 1; i <= NUM_EQUIPOTENTIALS; i++) {
            const levelMag = MAGNITUDE_FIXA * (NUM_EQUIPOTENTIALS / i) * 0.4 * K_ELETROSTATICA; 
            levels.push(levelMag);
            levels.push(-levelMag);
        }
        
        // 3. Desenhar as linhas de contorno (Marching Squares)
        
        ctx.lineWidth = 2;
        levels.forEach(level => {
            ctx.beginPath();
            
            // Cor: Vermelho para positivo, Azul para negativo (Azul para Equipotenciais!)
            ctx.strokeStyle = level > 0 ? "rgba(0, 0, 255, 0.7)" : "rgba(0, 0, 255, 0.7)"; 
            
            for (let i = 0; i < gridWidth; i++) {
                for (let j = 0; j < gridHeight; j++) {
                    
                    const p = [
                        { x: i * resolution,    y: j * resolution,      v: potentialGrid[i][j] },
                        { x: (i + 1) * resolution, y: j * resolution,      v: potentialGrid[i+1][j] },
                        { x: (i + 1) * resolution, y: (j + 1) * resolution, v: potentialGrid[i+1][j+1] },
                        { x: i * resolution,    y: (j + 1) * resolution, v: potentialGrid[i][j+1] }
                    ];

                    let caseIndex = 0;
                    if (p[0].v > level) caseIndex |= 1;
                    if (p[1].v > level) caseIndex |= 2;
                    if (p[2].v > level) caseIndex |= 4;
                    if (p[3].v > level) caseIndex |= 8;
                    
                    // Interpolação Linear para encontrar o ponto exato na borda
                    const interp = (p1, p2) => {
                        if (Math.abs(p1.v - p2.v) < 1e-6) return p1;
                        if (Math.abs(p1.v - p2.v) < 1e-6) return p1;
                        const t = (level - p1.v) / (p2.v - p1.v);
                        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
                    };

                    const a = interp(p[0], p[1]); // Cima
                    const b = interp(p[1], p[2]); // Direita
                    const c = interp(p[2], p[3]); // Baixo
                    const d = interp(p[3], p[0]); // Esquerda

                    // Lógica do Marching Squares
                    switch (caseIndex) {
                        case 1: case 14: ctx.moveTo(d.x, d.y); ctx.lineTo(a.x, a.y); break;
                        case 2: case 13: ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); break;
                        case 3: case 12: ctx.moveTo(d.x, d.y); ctx.lineTo(b.x, b.y); break;
                        case 4: case 11: ctx.moveTo(b.x, b.y); ctx.lineTo(c.x, c.y); break;
                        case 5:          ctx.moveTo(d.x, d.y); ctx.lineTo(a.x, a.y); ctx.moveTo(c.x, c.y); ctx.lineTo(b.x, b.y); break;
                        case 6: case 9:  ctx.moveTo(a.x, a.y); ctx.lineTo(c.x, c.y); break;
                        case 7: case 8:  ctx.moveTo(d.x, d.y); ctx.lineTo(c.x, c.y); break;
                        case 10:         ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.moveTo(d.x, d.y); ctx.lineTo(c.x, c.y); break;
                    }
                }
            }
            ctx.stroke();
        });
    }
    
    // --- Desenho de Linhas de Campo (Streamlines com Setas) ---

    function drawArrowHead(x, y, Ex, Ey, color) {
        const mag = Math.sqrt(Ex * Ex + Ey * Ey);
        if (mag === 0) return;
        
        const angle = Math.atan2(Ey, Ex);
        const size = 6; 

        ctx.fillStyle = color;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(-angle); 

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-size, size / 3);
        ctx.lineTo(-size, -size / 3);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }

    function drawFieldLines() {
        const startPoints = [];
        const initialOffset = 0.2; // Offset no mundo
        
        for (const c of CARGAS) {
            if (c.q > 0) { 
                // Inicia linhas em cargas POSITIVAS
                for (let i = 0; i < NUM_STREAMS; i++) {
                    const angle = (i / NUM_STREAMS) * 2 * Math.PI;
                    startPoints.push({
                        x: c.x + initialOffset * Math.cos(angle),
                        y: c.y + initialOffset * Math.sin(angle),
                        q: c.q 
                    });
                }
            } 
            // Se todas são negativas, inicia as linhas mais longe para mostrar o fluxo "entrando"
            else if (CARGAS.every(ch => ch.q < 0)) {
                for (let i = 0; i < NUM_STREAMS; i++) {
                    const angle = (i / NUM_STREAMS) * 2 * Math.PI;
                    startPoints.push({
                        x: c.x + (initialOffset + 1.5) * Math.cos(angle),
                        y: c.y + (initialOffset + 1.5) * Math.sin(angle),
                        q: c.q 
                    });
                }
            }
        }

        ctx.strokeStyle = "#DC3545"; // Vermelho
        ctx.lineWidth = 1;
        
        startPoints.forEach(start => {
            let px = start.x;
            let py = start.y;
            let path = [];
            
            ctx.beginPath();
            const startCanvas = worldToCanvas(px, py);
            ctx.moveTo(startCanvas.x, startCanvas.y);
            
            for (let i = 0; i < 200; i++) { 
                const E_vector = getFieldAt(px, py);
                const mag = E_vector.mag;
                
                if (mag < 1e-4 || px < xLim[0] || px > xLim[1] || py < yLim[0] || py > yLim[1]) break;

                // Segue o campo (vetor E)
                const dx = E_vector.Ex / mag * STREAM_STEP_SIZE;
                const dy = E_vector.Ey / mag * STREAM_STEP_SIZE;
                
                px += dx;
                py += dy;
                
                if (CARGAS.some(c => Math.sqrt((px - c.x)**2 + (py - c.y)**2) < 0.25)) break; 
                
                const nextCanvas = worldToCanvas(px, py);
                ctx.lineTo(nextCanvas.x, nextCanvas.y);
                path.push({x: nextCanvas.x, y: nextCanvas.y, Ex: E_vector.Ex, Ey: E_vector.Ey});
            }
            ctx.stroke();
            
            // Adicionar setas na linha de campo
            if (path.length > 50) { 
                const scale = LARGURA_JANELA / (xLim[1] - xLim[0]);
                for (let i = 0; i < path.length; i += SETA_INTERVALO * scale / 2) {
                    const point = path[Math.floor(i)];
                    drawArrowHead(point.x, point.y, point.Ex, point.Ey, "#DC3545");
                }
            }
        });
    }

    function drawCharges() {
        for (const c of CARGAS) {
            ctx.beginPath();
            const pos = worldToCanvas(c.x, c.y);
            const radius = RAIO_CARGA;
            ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = c.cor;
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.fillStyle = "white";
            ctx.font = "bold 16px Inter";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(c.label, pos.x, pos.y);
        }
    }

    // --- Lógica de Arrastar (Drag and Drop) ---

    function getCanvasCursorPos(event) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        };
    }

    function handleMouseDown(event) {
        const canvasPos = getCanvasCursorPos(event);
        const worldPos = canvasToWorld(canvasPos.x, canvasPos.y);
        
        for (let i = 0; i < CARGAS.length; i++) {
            const c = CARGAS[i];
            const dx = worldPos.x - c.x;
            const dy = worldPos.y - c.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 0.5) { // Área de clique expandida no mundo
                isDragging = true;
                cargaArrastada = c;
                dragOffset.x = dx;
                dragOffset.y = dy;
                canvas.style.cursor = 'grabbing';
                break;
            }
        }
    }

    function handleMouseMove(event) {
        if (!isDragging || !cargaArrastada) return;
        
        const canvasPos = getCanvasCursorPos(event);
        const worldPos = canvasToWorld(canvasPos.x, canvasPos.y);

        // Atualiza a posição da carga arrastada
        cargaArrastada.x = Math.max(xLim[0], Math.min(xLim[1], worldPos.x - dragOffset.x));
        cargaArrastada.y = Math.max(yLim[0], Math.min(yLim[1], worldPos.y - dragOffset.y));
        
        animar(); // Redesenha a tela
    }

    function handleMouseUp() {
        if (isDragging) {
            isDragging = false;
            cargaArrastada = null;
            canvas.style.cursor = 'grab';
        }
    }
        
    // --- Loop Principal da Simulação ---

    function animar() {
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(0, 0, LARGURA_JANELA, ALTURA_JANELA);

        drawEquipotentials(); 
        drawFieldLines(); 
        
        drawCharges();
        
        // Mantém o loop ativo para permitir o arrastar
        requestAnimationFrame(animar);
    }

    // --- Lógica de Narração (TTS) ---

    const videoElement = document.getElementById('videoProfessor');
    const btnControle = document.getElementById('btnControleNaracao');

    let isSpeaking = false;
    let currentUtteranceIndex = 0;
    let portugueseVoice = null; 
    let voicesLoaded = false;

    // Adaptação do script para o Campo Equipotencial
    const SCRIPT_NARRACAO = [
        "Bem-vindo à Simulação de Campo Equipotencial.",
        "As linhas azuis são as Equipotenciais, pontos onde o Potencial V é constante. As linhas vermelhas são as linhas de Campo Elétrico E.",
        "Observe que as linhas Equipotenciais e as linhas de Campo são sempre perpendiculares entre si. Isso é uma regra fundamental da eletrostática.",
        "Você pode clicar e arrastar as cargas para reconfigurar o campo. Tente a configuração de Dipolo, Cargas Positivas, e Cargas Negativas.",
        "Lembre-se: Nenhum trabalho é realizado para mover uma carga ao longo de uma linha Equipotencial.",
        "Obrigado por utilizar a simulação."
    ];
    
    let utteranceArray = [];
    
    function loadVoices() {
        const voices = window.speechSynthesis.getVoices();
        
        if (voices.length === 0 && !voicesLoaded) {
             setTimeout(loadVoices, 200);
             return;
        }
        
        if (voicesLoaded) return; 

        portugueseVoice = voices.find(voice => voice.lang.includes('pt-BR') || voice.lang.includes('pt-PT'));

        utteranceArray = [];
        SCRIPT_NARRACAO.forEach((texto, index) => {
            const utterance = new SpeechSynthesisUtterance(texto);
            utterance.lang = 'pt-BR';
            if (portugueseVoice) {
                utterance.voice = portugueseVoice;
            }
            utterance.pitch = 1; 
            utterance.rate = 1.1; 
            
            // Correção: Configurar onend para progredir e iniciar a próxima
            utterance.onend = () => {
                currentUtteranceIndex++;
                if (currentUtteranceIndex < utteranceArray.length) {
                    window.speechSynthesis.speak(utteranceArray[currentUtteranceIndex]);
                } else {
                    handleNaracaoConcluida();
                }
            };
            utteranceArray.push(utterance);
        });
        
        voicesLoaded = true;
        console.log("Vozes TTS carregadas. Narração pronta para interagir.");
        
        btnControle.textContent = "▶ PLAY Narração";
        btnControle.disabled = false;
    }

    function setupVoices() {
        if (!('speechSynthesis' in window)) {
            btnControle.textContent = "TTS Indisponível";
            btnControle.disabled = true;
            return;
        }

        if (window.speechSynthesis.onvoiceschanged !== undefined) {
             window.speechSynthesis.onvoiceschanged = loadVoices;
        }
        loadVoices(); 
    }

    document.addEventListener('DOMContentLoaded', () => {
         setupVoices(); 
         if (videoElement) {
             // Tenta iniciar o vídeo em loop no DOMContentLoaded para compatibilidade.
             videoElement.play().catch(e => console.log("Vídeo não iniciado automaticamente."));
         }
    });
    
    function handleNaracaoConcluida() {
        window.speechSynthesis.cancel();
        isSpeaking = false;
        
        currentUtteranceIndex = 0; // Prepara para reiniciar
        
        btnControle.textContent = "▶ REINICIAR Narração";
        btnControle.classList.remove('playing');
        btnControle.classList.add('paused');
        btnControle.disabled = false;
    }

    function pausarNaracaoEVideo() {
        if (isSpeaking && window.speechSynthesis.speaking) {
            window.speechSynthesis.pause();
            isSpeaking = false;
            
            btnControle.textContent = "▶ CONTINUAR Narração";
            btnControle.classList.remove('playing');
            btnControle.classList.add('paused');
        }
    }
    
    function iniciarOuContinuarNaracaoEVideo() {
        if (!voicesLoaded || btnControle.disabled) {
             return;
        }

        if (isSpeaking && window.speechSynthesis.speaking) {
            // Se está falando, pausa
            pausarNaracaoEVideo();
        } else {
            // Se está pausada ou no início/fim
            isSpeaking = true;
            btnControle.textContent = "❚❚ PAUSE Narração";
            btnControle.classList.remove('paused');
            btnControle.classList.add('playing');

            if (window.speechSynthesis.paused) {
                // Se estava pausada, retoma
                window.speechSynthesis.resume();
            } else {
                // Se a fila acabou ou é a primeira vez, reinicia
                if (currentUtteranceIndex >= utteranceArray.length) {
                     currentUtteranceIndex = 0; 
                     window.speechSynthesis.cancel(); // Cancela o estado "concluído" ou pendente
                }
                
                // Cancela qualquer fala anterior, caso o usuário tenha trocado de aba/simulação
                window.speechSynthesis.cancel();
                
                // Inicia a partir do índice atual (0 ou o ponto de pausa)
                if (utteranceArray[currentUtteranceIndex]) {
                    window.speechSynthesis.speak(utteranceArray[currentUtteranceIndex]);
                }
            }
        }
    }


    // --- Inicialização (Ponto de entrada da Simulação) ---
    function iniciarSimulacao() {
        canvas = document.getElementById('eFieldCanvas');
        
        if (!canvas) {
            console.error("Elemento Canvas com ID 'eFieldCanvas' não encontrado.");
            return;
        }
        
        ctx = canvas.getContext('2d');
        canvas.width = LARGURA_JANELA;
        canvas.height = ALTURA_JANELA;
        
        // Inicializa os dados das cargas e configura a simulação
        inicializarCargas(); 

        // Configura os eventos de arrastar
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp); 
        
        // Configura o listener do botão TTS
        btnControle.addEventListener('click', iniciarOuContinuarNaracaoEVideo);

        // Inicia o loop de animação
        animar(); 
    }

    // Inicia a simulação com os valores padrão ao carregar a página
    window.onload = iniciarSimulacao;

</script>

</body>
</html>